<font size=5 face="楷体">软件过程及过程模型</font>

2020.9.24

<font size=4 face="楷体">	上节回顾：C时期，method与数据没有一个必然的连续性；敏捷开发？
	本节：过程模型与生命周期模型两个概念的区别：前者以人为主体，是从开发过程来看的；后者是从软件自身来看的；利用功能分解、面向对象分解来将艺术活变成工程活；
	将功能分解、面向对象分解与软件过程模型进行对应。
PS：工厂模型；
	开发软件第一步：不是写代码；design：思考整体的代码长啥样，包括modeling(帮助刻画问题，整理思路，来写代码eg：思维导图)；可以不要modeling吗：可以；对于很熟的和很简单的就不必要modeling了；所以modeling不算到整个过程中；空集->Requirements->Analysis->Design->Implementation(Episode)；ppt中图的虚线表示可以回退。遇到问题总是回退一级尝试解决，故问题出现的层数越高修复的代价越大。
	需求：也可以拆解为一个个小需求</font>

2020.10.22

<font size=4 face="楷体">	使用模型/描述功能最主要的信息：</font>

<font size=4 face="楷体">	用例图反映对系统的认识；圈是功能/用例；用以描述/对应需求；用例里面又会有正常事件流与可选事件流；过渡到结构层面：类图：聚集关联是一种弱联系，表示类的对象之间的关系，是一种整体和部分的关系；但拥有方死掉不影响被拥有方的存在；而组成关联是强联系，拥有者和被拥有者同生死；类图的作用：简介准确地反映问题领域的基本元素。包图：高级面向对象语言必须有，用于分而治之？行为层面：状态机图很少用，很难用；**活动图与顺序图**；通讯图与顺序图等价，前者由序号保证顺序，强调通信关系，较后者不常用；交互概观图也基本不用；后面的简要了解(会了解吗？)即可。</font>

2020.12.3

<font size=4 face="楷体">	建造者模式，图中黑色的菱形箭头表示后者于前者具有相同的生命周期，前者回收后者的空间也被回收；</font>

<font size=4 face="楷体">	原型模式：自己造自己，$clone$；这样的意义是不想用new；new一个对象是在堆里存放的；适配器模式：已有一个实现了的类，有一个要实现的类与它有对应关系但又不完全一致；面向接口编程：强制用户完成run所需部分；DogAdapter继承了Dog；Robot是被包装体，用到了它的方法、属性；</font>