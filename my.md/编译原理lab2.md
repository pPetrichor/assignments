# <p align="center"><font face="楷体">编译原理实验二报告</p></font>

<p align="right"><font size=4 face="楷体">姓名：王瀚霖 学号：181860092 队伍编号：15 邮箱：603102048@qq.com</font></p>


### <font face="楷体">一、实验完成度</font>

<font size=3 face="楷体">	完成了实验的必做内容与要求$2.2$：完成了语义分析与类型检查的任务。</font>

### <font face="楷体">二、编译方法(略)</font>

### <font face="楷体">三、功能实现思路方法</font>

- <font size=4 face="楷体" color=00bfff>结构体与类型表示设计：</font>

  <font size=3 face="楷体">	本次实验会涉及到整形变量、浮点型变量、数组、结构体定义、结构体变量与函数;考虑到$C$--语法只能在最外层定义函数、在内层调用函数，而且对于函数与变量之间可能存在的错误不做考察，因此可以将函数也归为一种变量。这样就将上述内容分为两类：变量与结构体定义。手册中给出了`Type_`与`FieldList_`两个结构体，利用它们可以对数组与结构体进行很好的定义；在我的实现中，用`Type_`来表示变量的类型。由于将函数也视为变量，所以变量的类型有四种：基本数据类型变量($int$与$float$)、数组变量、结构体变量与函数。这里结构体变量比较特殊，因为它的类型是自定义的结构体，所以类型还需要记录这个变量的类型对应的结构体名字是什么。基于以上考虑，设计`Type_`如下：</font>

  ```c
struct Type_
  {
      enum { BASIC, ARRAY, STRUCTURE, FUNCTION} kind;
      //变量可以是四种类型中的一种
      union
      {
          int basic;// int or float
          struct { Type elem; int size; } array;
          struct { FieldList field; char* name; } structure;
          // name记录对应类型的结构体名字
          struct { Type ret_type; FieldList params; } func;
          //函数类型需要记录返回类型与形参列表
      } u;
  };
  ```
  
  <font size=3 face="楷体">	对于结构体定义，它不可以被内层的变量覆盖，所以不适合与变量存在一张符号表中，在实现中与变量分开存储。一个结构体定义的内容包括其名字与域，因此用如下的数据结构对结构体的定义进行表示：</font>

  ```c
struct Struct_define //结构体定义符号表项
  {
      char name[33]; //记录结构体名字
      FieldList field; //记录结构体域
      sdefine next; //指向下一个结构体符号表项
  };
  ```
  
- <font size=4 face="楷体" color=#00bfff>符号表设计：</font>

  <font size=3 face="楷体">	根据手册提示，基于散列表实现了两张符号表，分别用于记录定义的结构体与定义的变量；前者不涉及到作用域的覆盖，因此只需要$open \quad hashing$散列表；后者要实现嵌套作用域的影响，根据手册提示利用十字链表和$open \quad hashing$散列表进行了实现。</font>

  <font size=3 face="楷体">	**结构体定义符号表与变量符号表实现**：结构体定义符号表就是一个简单的$open \quad hashing$散列表，不作过多描述；变量符号表稍显复杂：基本的思路是在$open \quad hashing$散列表的基础上用链表模拟一个栈，栈中的每个元素是指向一个链接起同一层变量的链表的指针；因此符号表项需要有两个指针，一个指向下一个映射到同一个$hash$值的表项，一个指向记录与自己在同一层变量的表项，从而构建起十字链表：</font>

  ```c
  typedef struct snode //变量符号表项
  {
      char name[33]; // name of variable
      Type type; //type of variable
      struct snode* hash_next; //for hash table list
      struct snode* layer_front; //for stack list
      int layer; //layer of variable
  }snode;
  typedef struct stanode //层数栈
  {
      struct stanode* front; //上一层的栈指针
      snode* last; //指向当前层最后一个变量
  }stanode;
  ```
  

<font size=3 face="楷体">	**符号表接口实现**：符号表的接口包括结构体定义、变量定义、结构体查找、变量查找以及最内层变量清除。</font>

<font size=3 face="楷体">	对于结构体定义，首先要查找两张符号表，确定没有与当前名字重复的结构体名或变量，然后向结构体定义符号表中加入当前结构体定义；对于变量定义，首先要查找结构体定义符号表，确保变量名不与结构体名重复；接着查找变量符号表：如果要定义变量所在层数大于栈记录的最内层层数，说明当前变量是新的作用域的第一个变量，则将栈长度加一，新构建一层，将变量加入其中；否则，如果查找结果发现没有当前变量或是有重名变量定义但其所在层数小于当前变量层数，都可以加入符号表(因为内层变量可以重复定义)；</font>

<font size=3 face="楷体">	向变量符号表中加入一个变量时，首先计算其哈希值，并在相应位置的链表**头部**插入新定义的变量；同时，在层数栈方面应该将它插入到链表头部，即**栈中的元素指向的永远是当前层的最后一个变量**；加入一个结构体定义比较简单，因为不涉及到之后的删除与最内层查找，故只需计算哈希值后将它插入到链表头部就可以；对于结构体与变量查找，只要计算哈希值后遍历相应槽的链表就可以了；如果找到则返回对应表项，否则返回空指针；因为插入变量定义时总是将后定义的插入到链表头部，所以按序查找返回的就是最内层定义的变量；</font>

<font size=3 face="楷体">	最内层变量的清除是考虑到一个作用域结束时，应该把里面定义的变量从符号表中删除，因为到了外层语句块这些变量就会消亡。删除的操作就是将栈顶元素存放的链表内容按序删除。因为之前插入时保证了链表内容的顺序是从尾部到头部，即同一层变量后定义的会在链表前部，而后定义的变量在插入时都会插入到散列表槽的链表头部，所以每次删除一个变量定义表项时，可以保证该表项位于对应散列表槽的链表头部。这样删除时只要计算一下哈希值然后删除链表第一个内容，就实现了$hash$维度内容的删除；删除完当前层变量后，执行一次$pop$，就完成了最内层变量的删除。</font>

- <font size=4 face="楷体" color=#00bfff>语义检查设计：</font>

  <font size=3 face="楷体">	在`semantic.c`中实现，就是为每一个产生式写一个语义函数，描述该产生式应该执行的动作，同时检查语义错误与类型匹配。这部分内容多数内容就是计算每一个变量的类型等属性值(利用继承属性和综合属性)，在此不做赘述，仅对实现过程中的一些tricks和手册未定义的错误进行说明。</font>
  
  - <font size=3 face="楷体">函数形参与函数体变量重名避免：在处理`CompSt`时，会进入新的作用域；但对于函数处理，如果在处理`CompSt`时才添加一层新的作用域，就不好保证函数形参与函数体变量不冲突；因此设置了一个标志位`if_func_param`，在处理形参前就新建一层作用域并将标志位置一，接着就可以将形参写到这一层中；之后处理`CompSt`时若标志位为1就不添加新的一层作用域了；</font>
  - <font size=3 face="楷体">为方便报错信息的打印，仿照`Exp`的处理过程实现了函数`get_Exp_name`，用于获得一个表达式的名字；</font>
  - <font size=3 face="楷体">匿名结构体的处理：根据要求每个匿名结构体类型具有一个独有的隐藏名字，因此在处理`StructSpecifier`时，如果发现`OptTag`为空，则为其分配一个独特的名字后记录到符号表中；对于`struct x;`这样的语句，理解为使用匿名结构体定义变量，因为匿名结构体名各不相同，所以上述语句存在使用未定义的结构体定义变量的错误；</font>
  - <font size=3 face="楷体">错误6的检测：直接从语法层面检查，处理`Exp`中的赋值语句时检测赋值号 左边的表达式，如果不是ID、Exp LB Exp RB以及Exp DOT ID就报错；</font>
